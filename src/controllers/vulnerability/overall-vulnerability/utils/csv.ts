import { writeFile } from "fs/promises";
import { VulnerabilityCommonModelServiceResult } from "../../../../services/vulnerability";
import { SingleTransitCollisionRiskControllerResult } from "../../single-transit-risk";
import { stringify } from "csv-stringify/sync";
import * as path from "path";
import { FlightHeightTransitRiskResponse } from "../../flight-height-transit-risk";
import { sum } from "lodash";

export const writeOverallVulnerabilityCsv = async (
  results:
    | {
        proportionAtRotorHeight?: number;
        single: SingleTransitCollisionRiskControllerResult;
        extended: FlightHeightTransitRiskResponse;
        allExtended: VulnerabilityCommonModelServiceResult;
        allSingle?: VulnerabilityCommonModelServiceResult;
        timeOfWorkPerMonth?: number[];
        birdDensitiesPerMonth: number[];
      }
    | {
        proportionAtRotorHeight?: number;
        single: SingleTransitCollisionRiskControllerResult;
        extended?: FlightHeightTransitRiskResponse;
        allExtended?: VulnerabilityCommonModelServiceResult;
        allSingle: VulnerabilityCommonModelServiceResult;
        timeOfWorkPerMonth?: number[];
        birdDensitiesPerMonth: number[];
      },
  filename: string
) => {
  const monthsHeader = totalCsvRow({
    values: [
      "Jan",
      "Dec",
      "Feb",
      "March",
      "Apr",
      "May",
      "June",
      "July",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
    ],
    total: "Year average",
  });
  const timeOfWorkPerMonth = results.timeOfWorkPerMonth
    ? new Array(12)
        .fill(0)
        .map((it, index) => results.timeOfWorkPerMonth?.[index] || 0)
    : new Array(12).fill(1);
  const averageTimeOfWork = timeOfWorkPerMonth.reduce(
    (acc, it) => acc + it / 12,
    0
  );
  const birdDensitiesPerMonth = new Array(12)
    .fill(0)
    .map((it, index) => results.birdDensitiesPerMonth[index] || 0);
  const table: (string | number)[][] = [monthsHeader];
  table.push(
    totalCsvRow({
      values: timeOfWorkPerMonth.map((it, index) => Math.round(it * 100) + "%"),
      total: Math.round(averageTimeOfWork * 100) + "%",
    })
  );

  table.push(totalCsvRow({ baseTitle: "Stage A - flight activity" }));
  table.push(
    totalCsvRow({
      title: "Daytime areal bird density",
      unit: "birds/sq km",

      values: birdDensitiesPerMonth,
    })
  );
  const fluxFactorsPerMonth = (results.allSingle || results.allExtended)!
    .fluxFactorsPerMonth;

  const dayHoursPerMonth = (results.allSingle || results.allExtended)!
    .dayHoursPerMonth;

  const nightHoursPerMonth = (results.allSingle || results.allExtended)!
    .nightHoursPerMonth;
  table.push(
    totalCsvRow({
      title: "Proportion at rotor height",
      singleValue: results.proportionAtRotorHeight,
    })
  );
  table.push(
    totalCsvRow({
      title: "Total daylight hours per month",
      unit: "hrs",
      values: dayHoursPerMonth,
    })
  );

  table.push(
    totalCsvRow({
      title: "Total night hours per month",
      unit: "hrs",
      values: nightHoursPerMonth,
    })
  );
  table.push(
    totalCsvRow({
      title: "Flux factor",
      values: fluxFactorsPerMonth,
    })
  );
  table.push(
    totalCsvRow({
      title: "",
      values: [],
      total: "Per annual year",
    })
  );

  table.push(totalCsvRow({}));
  if (results.allSingle) {
    table.push(totalCsvRow({ baseTitle: "Basic model" }));
    table.push(
      totalCsvRow({
        title: "Potential bird transits through rotors",
        unit: "",
        values: results.allSingle?.potentialTransitsPerMonth,
        total: results.allSingle?.potentialTransitsPerMonth.reduce(
          (a, b) => a + b,
          0
        ),
      })
    );
    table.push(
      totalCsvRow({
        title: "Collision risk for single rotor transit",
        unit: "",
        singleValue: results.single.total * 100 + "%",
      })
    );

    table.push(
      totalCsvRow({
        title:
          "Collisions for entire windfarm, allowing for non-op time, assuming no avoidance",
        unit: "",
        values: results.allSingle.potentialCollisionsPerMonth,
        total: results.allSingle.potentialCollisionsPerMonth.reduce(
          (a, b) => a + b
        ),
      })
    );
    table.push(totalCsvRow({}));

    table.push(
      ...getAssumingAvoidancesRows(
        results.allSingle.collisionsAssumingAvoidance
      )
    );
    table.push(totalCsvRow({}));
  }
  if (results.allExtended) {
    table.push(
      totalCsvRow({
        title: "Proportion at rotor height",
        singleValue: results.extended!.proportionAtRotorHeight,
      })
    );
    table.push(
      totalCsvRow({
        title: "Potential bird transits through rotors",
        singleValue: results.extended!.fluxIntegral,
        values: results.allExtended.potentialTransitsPerMonth,
        total: results.allExtended.potentialTransitsPerMonth.reduce(
          (a, b) => a + b,
          0
        ),
      })
    );
    table.push(
      totalCsvRow({
        title: "Collisions assuming no avoidance",
        singleValue: results.extended!.collisionIntegral,
        values: results.allExtended.potentialCollisionsPerMonth,
        total: results.allExtended.potentialCollisionsPerMonth.reduce(
          (a, b) => a + b,
          0
        ),
      })
    );
    table.push(
      totalCsvRow({
        title: "Average collision risk for single rotor transit",
        singleValue:
          results.extended!.collisionIntegral / results.extended!.fluxIntegral,
      })
    );
    table.push(totalCsvRow({}));

    table.push(
      ...getAssumingAvoidancesRows(
        results.allExtended.collisionsAssumingAvoidance
      )
    );
    table.push(totalCsvRow({}));
  }

  await writeFile(path.join(filename, "overall.csv"), await stringify(table));
};
const totalCsvRow = ({
  title,
  unit,
  singleValue,
  values,
  total,
  baseTitle,
}: {
  baseTitle?: string | number;
  title?: number | string;
  unit?: number | string;
  singleValue?: number | string;
  values?: (number | string)[];
  total?: number | string;
}) => {
  const allValues = new Array(12)
    .fill("")
    .map((it, index) => values?.[index] ?? "");
  return [
    baseTitle ?? "",
    title ?? "",
    singleValue ?? "",
    ...allValues,
    "",
    total ?? "",
  ];
};
export const getAssumingAvoidancesRows = (collisionAssumingAvoidance: {
  [p: number]: number[];
}) => {
  const rows: any[] = [];
  Object.entries(collisionAssumingAvoidance).forEach(([it, values], index) => {
    let title = "";
    if (!index) {
      title = "Collisions assuming avoidance rate";
    }
    rows.push(
      totalCsvRow({
        title,
        singleValue: Number(it) * 100 + "%",
        values: values,
        total: sum(values),
      })
    );
  });
  return rows;
};
